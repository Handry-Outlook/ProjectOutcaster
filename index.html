<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Convective Outlook Platform</title>
  <script defer src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.5/babel.min.js"></script>
  <script defer src="https://cdn.tailwindcss.com"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/react-router-dom@5.2.0/umd/react-router-dom.min.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.2/firebase-compat.js"></script>
  <script defer src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script defer src="https://unpkg.com/@mapbox/mapbox-gl-draw@1.4.2/dist/mapbox-gl-draw.js"></script>
  <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script defer src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script defer src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" />
  <link rel="stylesheet" href="https://unpkg.com/@mapbox/mapbox-gl-draw@1.4.2/dist/mapbox-gl-draw.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
</head>
<body>
  <div id="root" className="min-h-screen bg-gray-50"></div>

  <script type="text/babel">
    if (!window.ReactRouterDOM) {
      console.error('ReactRouterDOM not loaded. Check CDN link or network.');
      throw new Error('ReactRouterDOM is undefined');
    }

    const { useState, useEffect, useRef } = React;
    const { BrowserRouter, Switch, Route, Link, useHistory, Redirect } = window.ReactRouterDOM;
    const { createRoot } = ReactDOM;

    const firebaseConfig = { apiKey: "AIzaSyDCCldk6q6R10O_hrEocjsGybQkmHEF2g4", authDomain: "convective-outlook-5dfbc.firebaseapp.com", projectId: "convective-outlook-5dfbc", storageBucket: "convective-outlook-5dfbc.firebasestorage.app", messagingSenderId: "452758486520", appId: "1:452758486520:web:9b0670240af6a4396caa0d" };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    const UK_BBOX = [-11, 49, 2, 61];
    const STRIKE_RADIUS_KM = 40;
    const RISK_WEIGHTS = {
      'low risk': 1.0,
      'slight risk': 1.5,
      'enhanced risk': 2.0,
      'moderate risk': 2.5,
      'high risk': 3.0,
      'severe risk': 3.5
    };
    const PENALTY_MULTIPLIERS = {
      'low risk': 1.0,
      'slight risk': 1.2,
      'enhanced risk': 1.5,
      'moderate risk': 1.8,
      'high risk': 2.0,
      'severe risk': 2.2
    };
    const RISK_COLORS = {
      'low risk': '#66c2a4',
      'slight risk': '#fff200',
      'enhanced risk': '#ff7f27',
      'moderate risk': '#ec1c24',
      'high risk': '#b83dba',
      'severe risk': '#800080'
    };
    const RISK_ORDER = ['low risk', 'slight risk', 'enhanced risk', 'moderate risk', 'high risk', 'severe risk'];

    const waitForLeaflet = (callback) => {
      if (window.L) {
        callback();
      } else {
        const checkInterval = setInterval(() => {
          if (window.L) {
            clearInterval(checkInterval);
            callback();
          }
        }, 100);
        setTimeout(() => {
          if (!window.L) {
            console.error('Leaflet failed to load after timeout');
            clearInterval(checkInterval);
          }
        }, 5000);
      }
    };

    const fetchLightningData = async (date, setError) => {
      console.log('Fetching lightning data for date:', date);
      if (!date) {
        console.warn('No date provided for lightning data fetch');
        return [];
      }
      try {
        const startTime = new Date(`${date}T06:00:00+01:00`);
        const endTime = new Date(startTime);
        endTime.setDate(startTime.getDate() + 1);
        endTime.setHours(5, 59, 59, 999);
        console.log('Lightning data period:', startTime, 'to', endTime);

        const githubUrl = 'https://raw.githubusercontent.com/Handry6/lightning_data/refs/heads/main/lightning_data.json';
        const metOfficeBaseUrl = 'https://data.consumer-digital.api.metoffice.gov.uk/v1/lightning';
        let allStrikes = [];

        const fetchWithTimeout = async (url, timeout = 5000) => {
          const controller = new AbortController();
          const id = setTimeout(() => controller.abort(), timeout);
          try {
            const response = await fetch(url, { signal: controller.signal });
            clearTimeout(id);
            return response;
          } catch (err) {
            clearTimeout(id);
            throw err;
          }
        };

        let githubStrikes = [];
        try {
          console.log('Fetching from GitHub:', githubUrl);
          const githubResponse = await fetchWithTimeout(githubUrl);
          if (!githubResponse.ok) {
            throw new Error(`GitHub fetch failed: ${githubResponse.status}`);
          }
          const githubData = await githubResponse.json();
          if (!githubData?.lightning_strikes) {
            throw new Error('Invalid GitHub data format');
          }
          githubStrikes = githubData.lightning_strikes
            .map(s => ({
              time: new Date(s.strike_time),
              coordinates: s.coordinates
            }))
            .filter(s => s.time >= startTime && s.time <= endTime);
          console.log('GitHub strikes fetched:', githubStrikes.length);
        } catch (err) {
          console.warn('GitHub data fetch failed:', err);
          setError(prev => prev || 'Unable to fetch GitHub lightning data.');
        }

        let baseStrikes = [];
        let chunkStrikes = [];
        try {
          console.log('Fetching from Met Office:', metOfficeBaseUrl);
          const mainResponse = await fetchWithTimeout(metOfficeBaseUrl);
          if (!mainResponse.ok) {
            throw new Error(`Met Office base fetch failed: ${mainResponse.status}`);
          }
          const mainData = await mainResponse.json();
          if (!mainData?.lightning_strikes) {
            throw new Error('Invalid Met Office data format');
          }
          baseStrikes = mainData.lightning_strikes
            .map(s => ({
              time: new Date(s.strike_time),
              coordinates: s.coordinates
            }))
            .filter(s => s.time >= startTime && s.time <= endTime);
          console.log('Met Office base strikes fetched:', baseStrikes.length);

          const chunkUrls = mainData?.chunks?.map(chunk =>
            `${metOfficeBaseUrl}?last-minutes=1&chunk=${chunk.chunk}`
          ) || [];
          console.log('Chunk URLs:', chunkUrls);
          const chunkResponses = await Promise.all(
            chunkUrls.map(async url => {
              try {
                console.log('Fetching chunk:', url);
                const res = await fetchWithTimeout(url);
                if (!res.ok) {
                  console.warn(`Met Office chunk fetch failed for ${url}: ${res.status}`);
                  return null;
                }
                const data = await res.json();
                return data;
              } catch (err) {
                console.warn(`Met Office chunk fetch error for ${url}:`, err);
                return null;
              }
            })
          );
          chunkStrikes = chunkResponses.flatMap(response =>
            response?.lightning_strikes?.map(s => ({
              time: new Date(s.strike_time),
              coordinates: s.coordinates
            }))?.filter(s => s.time >= startTime && s.time <= endTime) || []
          );
          console.log('Met Office chunk strikes fetched:', chunkStrikes.length);
        } catch (err) {
          console.warn('Met Office API failed, using GitHub data only:', err);
          setError(prev => prev || 'Unable to fetch Met Office lightning data. Using GitHub data.');
        }

        allStrikes = [...githubStrikes, ...baseStrikes, ...chunkStrikes];
        console.log('Total strikes before filtering:', allStrikes.length);
        const seen = new Map();
        const filteredStrikes = allStrikes.filter(s => {
          if (!s.coordinates || s.coordinates.length !== 2 || isNaN(s.coordinates[0]) || isNaN(s.coordinates[1])) {
            console.warn('Invalid strike coordinates:', s);
            return false;
          }
          const key = `${s.coordinates.join(',')}_${s.time}`;
          if (!seen.has(key)) {
            seen.set(key, true);
            return true;
          }
          return false;
        }).filter(s => {
          const [lon, lat] = s.coordinates;
          return lon >= UK_BBOX[0] && lon <= UK_BBOX[2] && lat >= UK_BBOX[1] && lat <= UK_BBOX[3];
        });
        console.log('Filtered strikes:', filteredStrikes.length);

        if (filteredStrikes.length === 0) {
          setError(prev => prev || 'No lightning data available for the selected date.');
        }

        return filteredStrikes;
      } catch (err) {
        console.error('Error fetching lightning data:', err);
        setError('Failed to fetch lightning data.');
        return [];
      }
    };

    const NavBar = ({ user, username }) => (
      <nav className="bg-blue-700 p-4 text-white shadow-md relative">
        <div className="container mx-auto flex justify-between items-center">
          <ul className="flex space-x-6">
            <li><Link to="/" className="hover:text-blue-200">Welcome</Link></li>
            {user ? (
              <>
                <li><Link to="/create" className="hover:text-blue-200">Create Outlook</Link></li>
                <li><Link to="/view" className="hover:text-blue-200">View Outlooks</Link></li>
                {user.email === 'admin@example.com' && <li><Link to="/admin" className="hover:text-blue-200">Admin</Link></li>}
                <li><Link to="/leaderboard" className="hover:text-blue-200">Leaderboard</Link></li>
                <li><Link to="/archive" className="hover:text-blue-200">Archive</Link></li>
                <li><button onClick={() => auth.signOut()} className="hover:text-blue-200">Logout</button></li>
              </>
            ) : (
              <li><Link to="/account" className="hover:text-blue-200">Account</Link></li>
            )}
          </ul>
          {username && (
            <span className="absolute top-4 right-4 text-sm">
              Welcome, {username}
            </span>
          )}
        </div>
      </nav>
    );

    const WelcomePage = () => {
      const [error, setError] = useState(null);

      useEffect(() => {
        waitForLeaflet(() => {
          try {
            const map = L.map('welcome-map').setView([54.5, -3], 6);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              maxZoom: 19,
              attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map).on('tileerror', (error, tile) => {
              console.error('Tile error:', error, tile);
              setError('Failed to load map tiles');
            });

            db.collection('outlooks')
              .where('email', '==', 'admin@example.com')
              .orderBy('timestamp', 'desc')
              .limit(1)
              .get()
              .then(snapshot => {
                console.log('Admin outlook query returned', snapshot.size, 'documents');
                if (snapshot.empty) {
                  console.warn('No admin outlook found for email: admin@example.com');
                  setError('No Handry Outlook available');
                  return;
                }
                const data = snapshot.docs[0]?.data();
                console.log('Admin outlook data:', data);
                if (!data?.polygons || data.polygons.length === 0) {
                  console.warn('Admin outlook has no polygons:', data);
                  setError('No forecast areas available in Handry Outlook');
                  return;
                }
                const parsedPolygons = data.polygons.map(p => {
                  try {
                    return {
                      ...p,
                      geometry: {
                        ...p.geometry,
                        coordinates: JSON.parse(p.geometry.coordinates)
                      },
                      properties: {
                        ...p.properties,
                        Name: p.properties.Name || 'low risk',
                        color: p.properties.color || RISK_COLORS[p.properties.Name?.toLowerCase() || 'low risk']
                      }
                    };
                  } catch (err) {
                    console.error('Error parsing polygon:', p, err);
                    return null;
                  }
                }).filter(p => p !== null);
                console.log('Parsed polygons for WelcomePage:', parsedPolygons);

                if (parsedPolygons.length === 0) {
                  console.warn('No valid polygons after parsing');
                  setError('Invalid forecast areas in Handry Outlook');
                  return;
                }

                const polygonsByRisk = RISK_ORDER.reduce((acc, risk) => {
                  acc[risk] = parsedPolygons.filter(p => p.properties.Name.toLowerCase() === risk);
                  return acc;
                }, {});
                console.log('Polygons by risk:', polygonsByRisk);

                RISK_ORDER.forEach(risk => {
                  if (polygonsByRisk[risk].length > 0) {
                    const layer = L.geoJSON(polygonsByRisk[risk], {
                      style: feature => {
                        const riskLevel = feature.properties.Name?.toLowerCase();
                        const color = RISK_COLORS[riskLevel] || '#66c2a4';
                        if (!RISK_COLORS[riskLevel]) {
                          console.warn('Invalid risk level:', riskLevel, 'for polygon', feature);
                        }
                        console.log('Assigning color for', feature.properties.Name, ':', color);
                        return {
                          color,
                          fillColor: color,
                          fillOpacity: 0.4
                        };
                      }
                    }).addTo(map);
                    console.log('Added GeoJSON layer for', risk);
                  }
                });
                setTimeout(() => {
                  map.invalidateSize();
                  console.log('Map size invalidated for WelcomePage');
                }, 100);
              })
              .catch(err => {
                console.error('Error fetching admin outlook:', err);
                if (err.code === 'failed-precondition' && err.message.includes('index')) {
                  setError('Database index required. Please contact the administrator to create an index for outlooks by email and timestamp.');
                } else {
                  setError(`Failed to load Handry Outlook data: ${err.message}`);
                }
              });

            return () => {
              console.log('Cleaning up WelcomePage map');
              map.remove();
            };
          } catch (err) {
            console.error('Error initializing WelcomePage map:', err);
            setError('Failed to initialize map');
          }
        });
      }, []);

      return (
        <div className="p-6 container mx-auto">
          <h1 className="text-3xl font-bold text-gray-800 mb-4">Welcome to Convective Outlook</h1>
          {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
          <p className="text-gray-600 mb-4">View Handry Outlook's forecast below:</p>
          <div id="welcome-map" className="h-[500px] w-full rounded-lg shadow-md"></div>
        </div>
      );
    };

    const AccountPage = ({ setUser, setUsername, setEmail }) => {
      const [email, setLocalEmail] = useState('');
      const [password, setPassword] = useState('');
      const [username, setLocalUsername] = useState('');
      const [error, setError] = useState(null);
      const history = useHistory();

      const checkUsernameAvailability = async (username) => {
        if (!username.match(/^[a-zA-Z0-9_-]{3,16}$/)) {
          return 'Username must be 3-16 characters, using letters, numbers, underscores, or hyphens.';
        }
        const snapshot = await db.collection('users').where('username', '==', username).get();
        return snapshot.empty ? null : 'Username is already taken.';
      };

      const handleLogin = async () => {
        try {
          const userCredential = await auth.signInWithEmailAndPassword(email, password);
          const userDoc = await db.collection('users').doc(userCredential.user.uid).get();
          if (userDoc.exists) {
            setUser(userCredential.user);
            setUsername(userDoc.data().username);
            setEmail(userCredential.user.email);
            history.push('/');
          } else {
            setError('User profile not found.');
          }
        } catch (err) {
          console.error('Login error:', err);
          setError(`Login failed: ${err.message}`);
        }
      };

      const handleSignup = async () => {
        if (!username) {
          setError('Please enter a username.');
          return;
        }
        const usernameError = await checkUsernameAvailability(username);
        if (usernameError) {
          setError(usernameError);
          return;
        }
        try {
          const userCredential = await auth.createUserWithEmailAndPassword(email, password);
          await db.collection('users').doc(userCredential.user.uid).set({
            username,
            email: userCredential.user.email
          });
          setUser(userCredential.user);
          setUsername(username);
          setEmail(userCredential.user.email);
          history.push('/');
        } catch (err) {
          console.error('Signup error:', err);
          setError(`Signup failed: ${err.message}`);
        }
      };

      return (
        <div className="p-6 max-w-md mx-auto">
          <h1 className="text-3xl font-bold text-gray-800 mb-6">Account</h1>
          {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
          <input
            type="text"
            value={username}
            onChange={e => setLocalUsername(e.target.value)}
            placeholder="Username"
            className="w-full p-3 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <input
            type="email"
            value={email}
            onChange={e => setLocalEmail(e.target.value)}
            placeholder="Email"
            className="w-full p-3 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <input
            type="password"
            value={password}
            onChange={e => setPassword(e.target.value)}
            placeholder="Password"
            className="w-full p-3 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <div className="flex space-x-4">
            <button onClick={handleLogin} className="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition">Login</button>
            <button onClick={handleSignup} className="bg-green-600 text-white p-3 rounded-lg hover:bg-green-700 transition">Sign Up</button>
          </div>
        </div>
      );
    };

    const CreateOutlookPage = ({ user, username, email }) => {
  const [drawnItems, setDrawnItems] = useState([]);
  const [riskLevel, setRiskLevel] = useState('low risk');
  const [severeConditions, setSevereConditions] = useState({
    rainfall: false,
    hail: false,
    tornado: false,
    gusts: false
  });
  const [selectedPolygonId, setSelectedPolygonId] = useState(null);
  const [dataError, setDataError] = useState(null);
  const [sizeError, setSizeError] = useState(null);
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  const [forecastDate, setForecastDate] = useState(tomorrow.toISOString().split('T')[0]);
  const [drafts, setDrafts] = useState([]);
  const [selectedDraftId, setSelectedDraftId] = useState('');
  const [draftName, setDraftName] = useState('');
  const mapRef = useRef(null);
  const drawRef = useRef(null);

  const validatePolygonSizes = (polygons) => {
    console.log('Validating polygons:', polygons);
    for (let i = 0; i < polygons.length; i++) {
      const poly1 = polygons[i];
      if (!poly1.geometry || !poly1.geometry.coordinates || !poly1.properties.Name) {
        return `Error: Invalid polygon data at index ${i}`;
      }
      if (poly1.properties.Name.toLowerCase() === 'severe risk') continue; // Skip size validation for severe risk
      try {
        const area1 = turf.area(turf.polygon(poly1.geometry.coordinates));
        const riskIndex1 = RISK_ORDER.indexOf(poly1.properties.Name.toLowerCase());
        for (let k = i + 1; k < polygons.length; k++) {
          const poly2 = polygons[k];
          if (!poly2.geometry || !poly2.geometry.coordinates) {
            return `Error: Invalid polygon data at index ${k}`;
          }
          if (poly2.properties.Name.toLowerCase() === 'severe risk') continue; // Skip size validation for severe risk
          const area2 = turf.area(turf.polygon(poly2.geometry.coordinates));
          const riskIndex2 = RISK_ORDER.indexOf(poly2.properties.Name.toLowerCase());
          if (riskIndex1 > riskIndex2 && area1 > area2) {
            return `Error: ${poly1.properties.Name} area must be smaller than ${poly2.properties.Name} area.`;
          }
          if (riskIndex2 > riskIndex1 && area2 > area1) {
            return `Error: ${poly2.properties.Name} area must be smaller than ${poly1.properties.Name} area.`;
          }
        }
      } catch (err) {
        console.error('Error in validatePolygonSizes:', err);
        return `Error validating polygon sizes: ${err.message}`;
      }
    }
    return null;
  };

  const updateDrawnFeatures = () => {
    console.log('Updating drawn features');
    const features = drawRef.current.getAll().features;
    features.forEach(feature => {
      if (!feature.properties?.Name) {
        feature.properties = {
          Name: riskLevel,
          color: RISK_COLORS[riskLevel],
          severeConditions: riskLevel === 'severe risk' ? severeConditions : {}
        };
        console.log('Set properties for feature', feature.id, ':', feature.properties);
      }
    });
    features.sort((a, b) => RISK_ORDER.indexOf(b.properties.Name.toLowerCase()) - RISK_ORDER.indexOf(a.properties.Name.toLowerCase()));
    setDrawnItems(features);
    if (mapRef.current.getSource('drawnFeatures')) {
      mapRef.current.getSource('drawnFeatures').setData({
        type: 'FeatureCollection',
        features: features
      });
      console.log('Updated map source with features');
    }
  };

  useEffect(() => {
    if (!window.mapboxgl) {
      console.error('Mapbox GL JS not loaded');
      setDataError('Failed to load map. Please refresh the page.');
      return;
    }
    mapboxgl.accessToken = 'pk.eyJ1IjoiaGFuZHJ5MjAxOTEwMjYiLCJhIjoiY21jYWg2eG1lMDNkYTJxczVyOWM5bW9mciJ9.bA-qxiByTB_RseY1fgU4rg';
    const map = new mapboxgl.Map({
      container: 'create-map',
      style: 'mapbox://styles/mapbox/streets-v11',
      center: [-3, 54.5],
      zoom: 6,
      minZoom: 5,
      maxZoom: 10,
      maxBounds: [[UK_BBOX[0], UK_BBOX[1]], [UK_BBOX[2], UK_BBOX[3]]]
    });
    mapRef.current = map;

    const draw = new MapboxDraw({
      displayControlsDefault: false,
      controls: {
        polygon: true,
        trash: true
      },
      modes: {
        ...MapboxDraw.modes,
        draw_polygon: {
          ...MapboxDraw.modes.draw_polygon,
          finish: function(state) {
            const feature = MapboxDraw.modes.draw_polygon.finish.call(this, state);
            if (feature) {
              feature.properties = {
                Name: riskLevel,
                color: RISK_COLORS[riskLevel],
                severeConditions: riskLevel === 'severe risk' ? severeConditions : {}
              };
              this.addFeature(feature);
            }
            return feature;
          }
        }
      },
      styles: [
        {
          id: 'gl-draw-polygon-fill-inactive',
          type: 'fill',
          filter: ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon'], ['!=', 'Name', 'severe risk']],
          paint: {
            'fill-color': ['get', 'color'],
            'fill-opacity': 0.4
          }
        },
        {
          id: 'gl-draw-polygon-fill-active',
          type: 'fill',
          filter: ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon'], ['!=', 'Name', 'severe risk']],
          paint: {
            'fill-color': ['get', 'color'],
            'fill-opacity': 0.6
          }
        },
        {
          id: 'gl-draw-polygon-stroke-inactive',
          type: 'line',
          filter: ['all', ['==', 'active', 'false'], ['==', '$type', 'Polygon']],
          paint: {
            'line-color': ['case', ['==', ['get', 'Name'], 'severe risk'], '#000000', ['get', 'color']],
            'line-width': 2
          }
        },
        {
          id: 'gl-draw-polygon-stroke-active',
          type: 'line',
          filter: ['all', ['==', 'active', 'true'], ['==', '$type', 'Polygon']],
          paint: {
            'line-color': ['case', ['==', ['get', 'Name'], 'severe risk'], '#000000', ['get', 'color']],
            'line-width': 3
          }
        },
        {
          id: 'gl-draw-severe-fill',
          type: 'fill',
          filter: ['all', ['==', '$type', 'Polygon'], ['==', 'Name', 'severe risk']],
          paint: {
            'fill-opacity': 0
          }
        },
        {
          id: 'gl-draw-vertex',
          type: 'circle',
          filter: ['all', ['==', 'meta', 'vertex'], ['==', '$type', 'Point']],
          paint: {
            'circle-radius': 5,
            'circle-color': '#fff',
            'circle-stroke-color': '#000',
            'circle-stroke-width': 2
          }
        }
      ]
    });
    map.addControl(draw);
    drawRef.current = draw;

    map.on('draw.create', (e) => {
      console.log('Draw create event:', e);
      const feature = e.features[0];
      feature.properties = {
        Name: riskLevel,
        color: RISK_COLORS[riskLevel],
        severeConditions: riskLevel === 'severe risk' ? severeConditions : {}
      };
      console.log('Created feature', feature.id, 'with properties:', feature.properties);
      const newItems = [...drawnItems, feature];
      const validationError = validatePolygonSizes(newItems);
      if (validationError) {
        setSizeError(validationError);
        draw.delete(feature.id);
      } else {
        setSizeError(null);
        setDrawnItems(newItems);
        setSelectedPolygonId(feature.id);
      }
      updateDrawnFeatures();
    });

    map.on('draw.update', updateDrawnFeatures);
    map.on('draw.delete', updateDrawnFeatures);
    map.on('draw.selectionchange', (e) => {
      const selected = e.features[0]?.id;
      setSelectedPolygonId(selected || null);
      if (selected) {
        const feature = drawRef.current.get(selected);
        if (feature) {
          setRiskLevel(feature.properties.Name);
          if (feature.properties.Name === 'severe risk') {
            setSevereConditions(feature.properties.severeConditions || {
              rainfall: false,
              hail: false,
              tornado: false,
              gusts: false
            });
          } else {
            setSevereConditions({
              rainfall: false,
              hail: false,
              tornado: false,
              gusts: false
            });
          }
        }
      }
    });

    map.on('load', () => {
      console.log('Map loaded');
      map.addSource('drawnFeatures', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
      map.addLayer({
        id: 'drawnPolygons',
        type: 'fill',
        source: 'drawnFeatures',
        filter: ['!=', 'Name', 'severe risk'],
        paint: {
          'fill-color': ['get', 'color'],
          'fill-opacity': 0.4
        }
      });
      map.addLayer({
        id: 'drawnPolygonsOutline',
        type: 'line',
        source: 'drawnFeatures',
        paint: {
          'line-color': ['case', ['==', ['get', 'Name'], 'severe risk'], '#000000', ['get', 'color']],
          'line-width': 2
        }
      });
      map.addLayer({
        id: 'drawnSeverePolygons',
        type: 'fill',
        source: 'drawnFeatures',
        filter: ['==', 'Name', 'severe risk'],
        paint: {
          'fill-opacity': 0
        }
      });
    });

    db.collection('drafts')
      .where('email', '==', email)
      .get()
      .then(snapshot => {
        const draftsData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        console.log('Fetched drafts:', draftsData);
        setDrafts(draftsData);
      })
      .catch(err => {
        console.error('Error fetching drafts:', err);
        setDataError('Failed to load drafts');
      });

    return () => {
      console.log('Cleaning up CreateOutlookPage map');
      map.remove();
    };
  }, [email]);

  const updateRiskLevel = (newRiskLevel) => {
    console.log('Updating risk level to:', newRiskLevel);
    setRiskLevel(newRiskLevel);
    if (selectedPolygonId) {
      const feature = drawRef.current.get(selectedPolygonId);
      if (feature) {
        drawRef.current.setFeatureProperty(selectedPolygonId, 'Name', newRiskLevel);
        drawRef.current.setFeatureProperty(selectedPolygonId, 'color', RISK_COLORS[newRiskLevel]);
        drawRef.current.setFeatureProperty(selectedPolygonId, 'severeConditions', newRiskLevel === 'severe risk' ? severeConditions : {});
        console.log('Updated feature', selectedPolygonId, 'to', newRiskLevel);
        updateDrawnFeatures();
      }
    }
  };

  const updateSevereConditions = (newConditions) => {
    console.log('Updating severe conditions:', newConditions);
    setSevereConditions(newConditions);
    if (selectedPolygonId && riskLevel === 'severe risk') {
      drawRef.current.setFeatureProperty(selectedPolygonId, 'severeConditions', newConditions);
      console.log('Updated severe conditions for feature', selectedPolygonId);
      updateDrawnFeatures();
    }
  };

  const submitOutlook = async () => {
    console.log('Submitting outlook with drawnItems:', drawnItems, 'forecast date:', forecastDate);
    if (drawnItems.length === 0) {
      console.warn('No polygons drawn');
      alert('Please draw at least one polygon before submitting.');
      return;
    }
    if (!forecastDate) {
      console.warn('No forecast date provided');
      alert('Please select a forecast date.');
      return;
    }
    const currentDate = new Date('2025-06-25');
    const selectedDateTime = new Date(forecastDate);
    if (selectedDateTime <= currentDate) {
      console.warn('Selected date is invalid or in the past:', forecastDate);
      alert('Forecast date cannot be in the past or today.');
      return;
    }
    const validationError = validatePolygonSizes(drawnItems);
    if (validationError) {
      console.warn('Validation error:', validationError);
      alert(`Validation error: ${validationError}`);
      return;
    }

    try {
      const serializedPolygons = drawnItems.map(polygon => ({
        ...polygon,
        geometry: {
          ...polygon.geometry,
          coordinates: JSON.stringify(polygon.geometry.coordinates)
        },
        properties: {
          ...polygon.properties,
          Name: polygon.properties.Name,
          color: RISK_COLORS[polygon.properties.Name.toLowerCase()]
        }
      }));
      console.log('Serialized polygons for Firestore:', serializedPolygons);

      const outlookRef = await db.collection('outlooks').add({
        username,
        email: email || user.email,
        polygons: serializedPolygons,
        date: forecastDate,
        severeConditions: drawnItems.some(item => item.properties.Name === 'severe risk') ? severeConditions : {},
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        score: null
      });
      console.log('Outlook saved, ID:', outlookRef.id);

      alert('Outlook submitted successfully! Score will be calculated after the forecast period ends.');
      setDrawnItems([]);
      setSelectedPolygonId(null);
      drawRef.current.deleteAll();
      if (mapRef.current.getSource('drawnFeatures')) {
        mapRef.current.getSource('drawnFeatures').setData({
          type: 'FeatureCollection',
          features: []
        });
      }
    } catch (err) {
      console.error('Error submitting outlook:', err);
      alert(`Submission failed: ${err.message}`);
    }
  };

  const saveDraft = async () => {
    if (!draftName) {
      alert('Please enter a name for the draft.');
      return;
    }
    if (drawnItems.length === 0) {
      alert('Please draw at least one polygon to save as a draft.');
      return;
    }
    if (!forecastDate) {
      alert('Please select a forecast date.');
      return;
    }
    try {
      const serializedPolygons = drawnItems.map(polygon => ({
        ...polygon,
        geometry: {
          ...polygon.geometry,
          coordinates: JSON.stringify(polygon.geometry.coordinates)
        },
        properties: {
          ...polygon.properties,
          Name: polygon.properties.Name,
          color: RISK_COLORS[polygon.properties.Name.toLowerCase()]
        }
      }));
      const draftData = {
        username,
        email: email || user.email,
        polygons: serializedPolygons,
        date: forecastDate,
        name: draftName,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      };
      let draftRef;
      if (selectedDraftId) {
        draftRef = await db.collection('drafts').doc(selectedDraftId).set(draftData);
        console.log('Draft updated, ID:', selectedDraftId);
      } else {
        draftRef = await db.collection('drafts').add(draftData);
        console.log('Draft saved, ID:', draftRef.id);
        setSelectedDraftId(draftRef.id);
      }
      const draftsSnapshot = await db.collection('drafts').where('email', '==', email).get();
      setDrafts(draftsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })));
      alert('Draft saved successfully!');
    } catch (err) {
      console.error('Error saving draft:', err);
      alert(`Failed to save draft: ${err.message}`);
    }
  };

  const loadDraft = (draftId) => {
    const draft = drafts.find(d => d.id === draftId);
    if (!draft) {
      console.error('Draft not found:', draftId);
      return;
    }
    console.log('Loading draft:', draftId, draft);
    setSelectedDraftId(draftId);
    setDraftName(draft.name);
    setForecastDate(draft.date);
    const parsedPolygons = draft.polygons.map(p => ({
      ...p,
      geometry: {
        ...p.geometry,
        coordinates: JSON.parse(p.geometry.coordinates)
      }
    }));
    setDrawnItems(parsedPolygons);
    drawRef.current.deleteAll();
    parsedPolygons.forEach(feature => {
      drawRef.current.add(feature);
    });
    if (mapRef.current.getSource('drawnFeatures')) {
      mapRef.current.getSource('drawnFeatures').setData({
        type: 'FeatureCollection',
        features: parsedPolygons
      });
    }
    setSelectedPolygonId(null);
    setRiskLevel('low risk');
    setSevereConditions({
      rainfall: false,
      hail: false,
      tornado: false,
      gusts: false
    });
  };

  const deletePolygon = (id) => {
    console.log('Deleting polygon:', id);
    drawRef.current.delete(id);
    setDrawnItems(drawnItems.filter(item => item.id !== id));
    setSelectedPolygonId(null);
    setRiskLevel('low risk');
    setSevereConditions({
      rainfall: false,
      hail: false,
      tornado: false,
      gusts: false
    });
    updateDrawnFeatures();
  };

  const handleSevereChange = (e) => {
    console.log('Handling severe change:', e.target.name, e.target.checked);
    const newConditions = {
      ...severeConditions,
      [e.target.name]: e.target.checked
    };
    updateSevereConditions(newConditions);
  };

  const clearPolygons = () => {
    console.log('Clearing polygons');
    setDrawnItems([]);
    setSelectedPolygonId(null);
    setSelectedDraftId('');
    setDraftName('');
    setRiskLevel('low risk');
    setSevereConditions({
      rainfall: false,
      hail: false,
      tornado: false,
      gusts: false
    });
    drawRef.current.deleteAll();
    setSizeError(null);
    if (mapRef.current.getSource('drawnFeatures')) {
      mapRef.current.getSource('drawnFeatures').setData({
        type: 'FeatureCollection',
        features: []
      });
      console.log('Cleared map source');
    }
  };

  return (
    <div className="p-6 container mx-auto">
      <h1 className="text-3xl font-bold text-gray-800 mb-6">Create Your Outlook</h1>
      <p className="text-gray-600 mb-4">Draw risk areas on the map and select their risk levels for the chosen date (06:00 to next day 05:59):</p>
      {dataError && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{dataError}</p>}
      {sizeError && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{sizeError}</p>}
      <div className="flex flex-col md:flex-row gap-6">
        <div className="md:w-1/3 bg-white p-6 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold text-gray-700 mb-4">Draft Management</h2>
          <input
            type="text"
            value={draftName}
            onChange={e => setDraftName(e.target.value)}
            placeholder="Draft Name"
            className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <select
            value={selectedDraftId}
            onChange={e => loadDraft(e.target.value)}
            className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="">Select a Draft</option>
            {drafts.map(draft => (
              <option key={draft.id} value={draft.id}>{draft.name} ({draft.date})</option>
            ))}
          </select>
          <button
            onClick={saveDraft}
            className="w-full bg-purple-600 text-white p-3 mb-4 rounded-lg hover:bg-purple-700 transition"
          >
            {selectedDraftId ? 'Update Draft' : 'Save as Draft'}
          </button>
          <h2 className="text-xl font-semibold text-gray-700 mb-4">Forecast Date</h2>
          <input
            type="date"
            value={forecastDate}
            onChange={e => setForecastDate(e.target.value)}
            min="2025-06-26"
            className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <h2 className="text-xl font-semibold text-gray-700 mb-4">Risk Level</h2>
          <select
            value={riskLevel}
            onChange={e => updateRiskLevel(e.target.value)}
            className="w-full p-2 mb-4 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            {RISK_ORDER.map(risk => (
              <option key={risk} value={risk}>{risk.charAt(0).toUpperCase() + risk.slice(1)}</option>
            ))}
          </select>
          {riskLevel === 'severe risk' && selectedPolygonId && (
            <>
              <h2 className="text-xl font-semibold text-gray-700 mb-4">Severe Conditions</h2>
              {['rainfall', 'hail', 'tornado', 'gusts'].map(condition => (
                <label key={condition} className="flex items-center mb-2">
                  <input
                    type="checkbox"
                    name={condition}
                    checked={severeConditions[condition]}
                    onChange={handleSevereChange}
                    className="mr-2 h-5 w-5 text-blue-600"
                  />
                  <span className="text-gray-600">
                    {condition.charAt(0).toUpperCase() + condition.slice(1)}
                    {condition === 'rainfall' && ' (>25mm/3hr)'}
                    {condition === 'hail' && ' (>2cm)'}
                    {condition === 'tornado' && ''}
                    {condition === 'gusts' && ' (>55mph)'}
                  </span>
                </label>
              ))}
            </>
          )}
          <h2 className="text-xl font-semibold text-gray-700 mb-4">Drawn Polygons</h2>
          <ul className="space-y-2 mb-4">
            {drawnItems.map(item => (
              <li
                key={item.id}
                className={`p-2 cursor-pointer rounded-lg ${selectedPolygonId === item.id ? 'bg-blue-100' : 'hover:bg-gray-100'}`}
                onClick={() => {
                  setSelectedPolygonId(item.id);
                  setRiskLevel(item.properties.Name);
                  if (item.properties.Name === 'severe risk') {
                    setSevereConditions(item.properties.severeConditions || {
                      rainfall: false,
                      hail: false,
                      tornado: false,
                      gusts: false
                    });
                  } else {
                    setSevereConditions({
                      rainfall: false,
                      hail: false,
                      tornado: false,
                      gusts: false
                    });
                  }
                  drawRef.current.changeMode('simple_select', { featureIds: [item.id] });
                }}
              >
                {item.properties.Name} (ID: {item.id.slice(0, 8)})
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    deletePolygon(item.id);
                  }}
                  className="ml-2 text-red-500 hover:text-red-700"
                >
                  Delete
                </button>
              </li>
            ))}
          </ul>
          <div className="flex space-x-4">
            <button
              onClick={submitOutlook}
              className="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 transition disabled:bg-blue-400"
              disabled={sizeError}
            >
              Submit Outlook
            </button>
            <button
              onClick={clearPolygons}
              className="bg-red-600 text-white p-3 rounded-lg hover:bg-red-700 transition"
            >
              Clear Polygons
            </button>
          </div>
        </div>
        <div className="md:w-2/3">
          <div id="create-map" className="h-[500px] w-full rounded-lg shadow-md"></div>
        </div>
      </div>
    </div>
  );
};

    const ViewOutlookPage = () => {
      const [outlooks, setOutlooks] = useState([]);
      const [selectedOutlook, setSelectedOutlook] = useState(null);
      const [error, setError] = useState(null);
      const mapRef = useRef(null);
      const geoJsonLayersRef = useRef([]);

      const calculateScore = async (polygons, forecastDate, outlookId) => {
        console.log('Calculating score for outlook:', outlookId, 'polygons:', polygons, 'forecast date:', forecastDate);
        if (!Array.isArray(polygons) || !polygons.length) {
          console.error('Invalid polygons array');
          throw new Error('No valid polygons provided for scoring');
        }
        try {
          const startTime = new Date(`${forecastDate}T06:00:00+01:00`);
          const endTime = new Date(startTime);
          endTime.setDate(endTime.getDate() + 1);
          endTime.setHours(5, 59, 59, 999);
          console.log('Score period:', startTime, 'to', endTime);

          const strikes = await fetchLightningData(forecastDate, setError);
          console.log('Strikes received:', strikes.length);

          const severeSnapshot = await db.collection('severe_reports')
            .where('date', '==', forecastDate)
            .get();
          const severeReports = severeSnapshot.docs
            .map(doc => ({ id: doc.id, ...doc.data() }))
            .filter(report => {
              if (!report.timestamp) return false;
              const reportTime = report.timestamp.toDate();
              return reportTime >= startTime && reportTime <= endTime;
            });
          console.log('Severe reports:', severeReports);

          let h = 0, m = 0, f = 0, q = 0, severity_penalties = 0;
          let severeScore = 0;

          const samplePoints = [];
          for (const polygon of polygons) {
            if (!polygon.geometry || !polygon.geometry.coordinates) {
              console.error('Invalid polygon geometry:', polygon);
              throw new Error('Invalid polygon geometry');
            }
            const poly = turf.polygon(polygon.geometry.coordinates);
            const bbox = turf.bbox(poly);
            console.log('Polygon bbox:', bbox);
            for (let i = 0; i < 10; i++) {
              const x = Math.random() * (bbox[2] - bbox[0]) + bbox[0];
              const y = Math.random() * (bbox[3] - bbox[1]) + bbox[1];
              const point = turf.point([x, y]);
              if (turf.booleanPointInPolygon(point, poly)) {
                samplePoints.push(point);
              }
            }
          }
          console.log('Sample points generated:', samplePoints.length);

          const allPoints = [
            ...strikes.map(s => {
              if (!s.coordinates || s.coordinates.length !== 2) {
                console.warn('Invalid strike coordinates:', s);
                return null;
              }
              return turf.point(s.coordinates);
            }).filter(p => p),
            ...samplePoints
          ];
          console.log('Total points for scoring:', allPoints.length);

          for (const point of allPoints) {
            const isStrike = strikes.some(s => {
              if (!s.coordinates || s.coordinates.length !== 2) return false;
              return turf.distance(point, turf.point(s.coordinates), { units: 'kilometers' }) <= STRIKE_RADIUS_KM;
            });
            let highestWeight = 0;
            let highestPenalty = 1;
            let inForecast = false;

            const density = isStrike
              ? strikes.reduce((count, s) => {
                  if (!s.coordinates || s.coordinates.length !== 2) return count;
                  return turf.distance(point, turf.point(s.coordinates), { units: 'kilometers' }) <= STRIKE_RADIUS_KM
                    ? count + 1
                    : count;
                }, 0) / (Math.PI * STRIKE_RADIUS_KM ** 2)
              : 0;
            const expectedRisk = density >= 1.0 ? 'severe risk'
                : density >= 0.5 ? 'high risk'
                : density >= 0.2 ? 'moderate risk'
                : density >= 0.01 ? 'slight risk'
                : 'low risk';
            const expectedWeight = RISK_WEIGHTS[expectedRisk] || 1.0;

            for (const polygon of polygons) {
              const poly = turf.polygon(polygon.geometry.coordinates);
              if (turf.booleanPointInPolygon(point, poly)) {
                inForecast = true;
                const riskLevel = polygon.properties.Name?.toLowerCase() || 'low risk';
                const weight = RISK_WEIGHTS[riskLevel] || 1.0;
                const penalty = PENALTY_MULTIPLIERS[riskLevel] || 1.0;
                if (weight > highestWeight) {
                  highestWeight = weight;
                  highestPenalty = penalty;
                }
              }
            }

            if (isStrike) {
              if (inForecast) {
                h += highestWeight;
                if (highestWeight < expectedWeight) {
                  severity_penalties += (expectedWeight - highestWeight);
                }
              } else {
                m += 1;
                if (expectedWeight > 1.0) {
                  severity_penalties += expectedWeight;
                }
              }
            } else {
              if (inForecast) {
                f += highestWeight * highestPenalty;
              } else {
                q += 1;
              }
            }
          }

          for (const polygon of polygons) {
            const poly = turf.polygon(polygon.geometry.coordinates);
            const polySevere = polygon.properties.severeConditions || {};
            severeReports.forEach(report => {
              if (!report.location || report.location.length !== 2) {
                console.warn('Invalid report location:', report);
                return;
              }
              const point = turf.point(report.location);
              if (turf.booleanPointInPolygon(point, poly)) {
                if (
                  (polySevere.rainfall && report.condition === 'Rainfall') ||
                  (polySevere.hail && report.condition === 'Hail') ||
                  (polySevere.tornado && report.condition === 'Tornado') ||
                  (polySevere.gusts && report.condition === 'Gusts')
                ) {
                  severeScore += 10;
                }
              }
            });
          }
          console.log('Scoring results:', { h, m, f, q, severity_penalties, severeScore });

          const total = h + m + f + q;
          const accuracy = total > 0 ? ((h + q) / total * 100) : 0;
          const finalScore = Math.min(100, Math.max(0, accuracy + severeScore - severity_penalties));
          console.log('Final score:', finalScore);

          await db.collection('outlooks').doc(outlookId).update({ score: finalScore });
          console.log('Score updated for outlook:', outlookId, finalScore);

          return finalScore;
        } catch (err) {
          console.error('Error in calculateScore:', err);
          throw err;
        }
      };

      const calculateAndUpdateScore = async (outlook) => {
        if (outlook.score != null) {
          console.log('Score already calculated for outlook:', outlook.id);
          return;
        }
        const endTime = new Date(outlook.date);
        endTime.setDate(endTime.getDate() + 1);
        endTime.setHours(5, 59, 59, 999);
        const currentTime = new Date('2025-06-25T20:04:00+01:00');
        if (currentTime < endTime) {
          console.log('Outlook period not yet ended:', outlook.id, 'end time:', endTime);
          return;
        }
        try {
          const parsedPolygons = outlook.polygons.map(p => ({
            ...p,
            geometry: {
              ...p.geometry,
              coordinates: JSON.parse(p.geometry.coordinates)
            },
            properties: {
              ...p.properties,
              Name: p.properties.Name || 'low risk',
              color: p.properties.color || RISK_COLORS[p.properties.Name?.toLowerCase() || 'low risk']
            }
          })).filter(p => p !== null);
          console.log('Parsed polygons for scoring:', parsedPolygons.length);
          const score = await calculateScore(parsedPolygons, outlook.date, outlook.id);
          setOutlooks(prev => prev.map(o => o.id === outlook.id ? { ...o, score } : o));
        } catch (err) {
          console.error('Error calculating score for outlook:', outlook.id, err);
          setError(`Failed to calculate score for outlook ${outlook.id}: ${err.message}`);
        }
      };

      useEffect(() => {
        console.log('Fetching outlooks for ViewOutlookPage');
        db.collection('outlooks').get()
          .then(snapshot => {
            const outlooksData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            console.log('Fetched outlooks:', outlooksData);
            setOutlooks(outlooksData);
            outlooksData.forEach(outlook => calculateAndUpdateScore(outlook));
          })
          .catch(err => {
            console.error('Error fetching outlooks:', err);
            setError('Failed to load outlooks');
          });
      }, []);

      useEffect(() => {
        waitForLeaflet(() => {
          try {
            console.log('Initializing Leaflet for ViewOutlookPage');
            const map = L.map('view-map').setView([54.5, -3], 6);
            mapRef.current = map;
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              maxZoom: 19,
              attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map).on('tileerror', error => {
              console.error('Tile error:', error);
              setError('Failed to load map tiles');
            });
            setTimeout(() => {
              map.invalidateSize();
              console.log('Map size invalidated for ViewOutlookPage');
            }, 100);
            return () => {
              console.log('Cleaning up ViewOutlookPage map');
              map.remove();
            };
          } catch (err) {
            console.error('Error initializing ViewOutlookPage map:', err);
            setError('Failed to initialize map');
          }
        });
      }, []);

      useEffect(() => {
        if (!mapRef.current || !selectedOutlook) return;
        console.log('Updating GeoJSON for outlook:', selectedOutlook.id);
        geoJsonLayersRef.current.forEach(layer => {
          if (mapRef.current.hasLayer(layer)) {
            mapRef.current.removeLayer(layer);
          }
        });
        geoJsonLayersRef.current = [];
        if (selectedOutlook.polygons) {
          const parsedPolygons = selectedOutlook.polygons
            .map(p => {
              try {
                return {
                  ...p,
                  geometry: {
                    ...p.geometry,
                    coordinates: JSON.parse(p.geometry.coordinates)
                  },
                  properties: {
                    ...p.properties,
                    Name: p.properties.Name || 'low risk',
                    color: p.properties.color || RISK_COLORS[p.properties.Name?.toLowerCase() || 'low risk']
                  }
                };
              } catch (err) {
                console.error('Error parsing polygon:', p, err);
                return null;
              }
            }).filter(p => p !== null);
          console.log('Parsed polygons for ViewOutlookPage:', parsedPolygons.length);

          const polygonsByRisk = RISK_ORDER.reduce((acc, risk) => {
            acc[risk] = parsedPolygons.filter(p => p.properties.Name?.toLowerCase() === risk);
            return acc;
          }, {});
          console.log('Polygons by risk:', polygonsByRisk);

          RISK_ORDER.forEach(risk => {
            if (polygonsByRisk[risk].length) {
              const layer = L.geoJSON(polygonsByRisk[risk], {
                style: feature => {
                  const riskLevel = feature.properties.Name?.toLowerCase() || 'low risk';
                  const color = RISK_COLORS[riskLevel] || '#66c2a4';
                  if (!RISK_COLORS[riskLevel]) {
                    console.warn('Invalid risk level:', riskLevel, 'for polygon', feature);
                  }
                  console.log('Assigning color for', feature.properties.Name, ':', color);
                  return {
                    color,
                    fillColor: color,
                    fillOpacity: 0.4
                  };
                }
              }).addTo(mapRef.current);
              geoJsonLayersRef.current.push(layer);
              console.log('Added GeoJSON layer for', risk);
            }
          });
          setTimeout(() => {
            if (mapRef.current) {
              mapRef.current.invalidateSize();
              console.log('Map size invalidated after GeoJSON layer update');
            }
          }, 100);
        }
      }, [selectedOutlook]);

      return (
        <div className="p-6 container mx-auto">
          <h1 className="text-3xl font-bold text-gray-800 mb-6">View Outlooks</h1>
          {error && <p className="text-red-500 mb-4 bg-red-100 p-3 rounded-lg">{error}</p>}
          <div className="flex flex-col md:flex-row gap-6">
            <div className="md:w-1/3 bg-white p-6 rounded-lg shadow-md">
              <ul className="space-y-2">
                {outlooks.map(outlook => (
                  <li
                    key={outlook.id}
                    onClick={() => {
                      setSelectedOutlook(outlook);
                      calculateAndUpdateScore(outlook);
                    }}
                    className="cursor-pointer p-3 hover:bg-gray-100 rounded-lg"
                  >
                    {outlook.username} - {outlook.date} {outlook.score != null ? `(Score: ${outlook.score.toFixed(2)})` : '(Score pending)'}
                  </li>
                ))}
              </ul>
            </div>
            <div className="md:w-2/3">
              <div id="view-map" className="h-[500px] w-full rounded-lg shadow-md"></div>
            </div>
          </div>
        </div>
      );
    };

    const AdminPage = ({ user, username }) => {
      const [error, setError] = useState(null);
      const history = useHistory();

      useEffect(() => {
        if (!user || user.email !== 'admin@example.com') {
          console.warn('Non-admin user attempted to access AdminPage:', user?.email);
          setError('Access denied: Admin privileges required.');
          history.push('/');
          return;
        }
        console.log('AdminPage accessed by:', user.email);
        waitForLeaflet(() => {
          try {
            const map = L.map('admin-map').setView([54.5, -3], 6);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              maxZoom: 19,
              attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map).on('tileerror', (error, tile) => {
              console.error('Tile error:', error, tile);
              setError('Failed to load map tiles');
            });
            map.on('click', e => {
              console.log('Map clicked at:', e.latlng, 'by user:', user.email);
              const condition = prompt('Enter severe weather condition (Rainfall, Hail, Tornado, or Gusts):');
              if (!condition || !['Rainfall', 'Hail', 'Tornado', 'Gusts'].includes(condition)) {
                console.warn('Invalid condition entered:', condition);
                setError('Invalid condition. Please enter Rainfall, Hail, Tornado, or Gusts.');
                return;
              }
              console.log('Attempting to save severe report:', { condition, location: [e.latlng.lat, e.latlng.lng] });
              db.collection('severe_reports').add({
                username,
                condition,
                location: [e.latlng.lat, e.latlng.lng],
                date: new Date().toISOString().split('T')[0],
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
              })
                .then(() => {
                  console.log('Severe report saved successfully');
                  setError('Report saved successfully!');
                  setTimeout(() => setError(null), 3000);
                })
                .catch(err => {
                  console.error('Error adding report:', err);
                  setError(`Failed to save report: ${err.message}`);
                  if (err.code === 'permission-denied') {
                    setError('Permission denied: Please ensure you are signed in as admin@example.com and Firestore rules are correctly configured.');
                  }
                });
            });
            setTimeout(() => {
              map.invalidateSize();
              console.log('Map size invalidated for AdminPage');
            }, 100);
            return () => {
              console.log('Cleaning up AdminPage map');
              map.remove();
            };
          } catch (err) {
            console.error('Error initializing AdminPage map:', err);
            setError('Failed to initialize map');
          }
        });
      }, [user, username, history]);

      return (
        <div className="p-6 container mx-auto">
          <h1 className="text-3xl font-bold text-gray-800 mb-6">Admin: Add Severe Weather Reports</h1>
          <p className="text-gray-600 mb-4">Click on the map to add a severe weather report.</p>
          {error && (
            <p className={`mb-4 bg-${error.includes('success') ? 'green' : 'red'}-100 p-3 rounded-lg text-${error.includes('success') ? 'green' : 'red'}-500`}>
              {error}
            </p>
          )}
          <div id="admin-map" className="h-[500px] w-full rounded-lg shadow-md"></div>
        </div>
      );
    };

    const LeaderboardPage = () => {
      const [outlooks, setOutlooks] = useState([]);
      const [sortBy, setSortBy] = useState('avgScore');

      const calculateAndUpdateScore = async (outlook) => {
        if (outlook.score != null) {
          console.log('Score already calculated for outlook:', outlook.id);
          return;
        }
        const endTime = new Date(outlook.date);
        endTime.setDate(endTime.getDate() + 1);
        endTime.setHours(5, 59, 59, 999);
        const currentTime = new Date('2025-06-25T20:04:00+01:00');
        if (currentTime < endTime) {
          console.log('Outlook period not yet ended:', outlook.id, endTime);
          return;
        }
        try {
          const parsedPolygons = outlook.polygons.map(p => ({
            ...p,
            geometry: {
              ...p.geometry,
              coordinates: JSON.parse(p.geometry.coordinates)
            },
            properties: {
              ...p.properties,
              Name: p.properties.Name || 'low risk',
              color: p.properties.color || RISK_COLORS[p.properties.Name?.toLowerCase() || 'low risk']
            }
          })).filter(p => p !== null);
          console.log('Parsed polygons for scoring:', parsedPolygons.length);
          const score = await calculateScore(parsedPolygons, outlook.date, outlook.id);
          setOutlooks(prev => prev.map(o => o.id === outlook.id ? { ...o, score } : o));
        } catch (err) {
          console.error('Error calculating score for outlook:', outlook.id, err);
        }
      };

      useEffect(() => {
        console.log('Fetching outlooks for LeaderboardPage');
        db.collection('outlooks').get()
          .then(snapshot => {
            const outlooksData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            console.log('Outlooks fetched:', outlooksData);
            setOutlooks(outlooksData);
            outlooksData.forEach(outlook => calculateAndUpdateScore(outlook));
          })
          .catch(err => {
            console.error('Error fetching outlooks:', err);
            setOutlooks([]);
          });
      }, []);

      const averagedScores = outlooks.reduce((acc, curr) => {
        const { username, score } = curr;
        if (!username || score == null) {
          console.warn('Invalid outlook data:', username, score);
          return acc;
        }
        acc[username] = acc[username] || { total: 0, count: 0 };
        acc[username].total += score;
        acc[username].count += 1;
        return acc;
      }, {});

      const sortedScores = Object.entries(averagedScores)
        .map(([username, score]) => ({
          username,
          avgScore: score.total / score.count
        }))
        .sort((a, b) => {
          if (sortBy === 'avgScore') {
            return b.avgScore - a.avgScore;
          }
          return a.username.localeCompare(b.username);
        });

      return (
        <div className="p-6 container mx-auto">
          <h1 className="text-3xl font-bold text-gray-800 mb-6">Leaderboard</h1>
          <select
            value={sortBy}
            onChange={e => setSortBy(e.target.value)}
            className="p-2 mb-4 border rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="avgScore">Sort by Average Score</option>
            <option value="username">Sort by Username</option>
          </select>
          <div className="bg-white rounded-lg shadow-md p-4">
            <table className="w-full text-left">
              <thead className="bg-blue-200">
                <tr>
                  <th className="p-4 text-gray-700">Username</th>
                  <th className="p-4 text-gray-700">Average Score</th>
                </tr>
              </thead>
              <tbody>
                {sortedScores.map(score => (
                  <tr key={score.username} className="border-t">
                    <td className="p-4">{score.username}</td>
                    <td className="p-4">{score.avgScore.toFixed(2)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      );
    };

    const ArchivePage = () => {
      const [date, setDate] = useState('');
      const [outlooks, setOutlooks] = useState([]);
      const [selectedOutlook, setSelectedOutlook] = useState(null);
      const [error, setError] = useState(null);
      const mapRef = useRef(null);
      const geoJsonLayersRef = useRef([]);
      const lightningLayerRef = useRef(null);

      useEffect(() => {
        waitForLeaflet(() => {
          try {
            console.log('Initializing Leaflet for ArchivePage');
            const map = L.map('archive-map').setView([54.5, -3], 6);
            mapRef.current = map;
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              maxZoom: 19,
              attribution: 'Â© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map).on('tileerror', (error, _) => {
              console.error('Tile error:', error);
              setError('Failed to load map tiles');
            });
            lightningLayerRef.current = L.layerGroup().addTo(map);
            console.log('Initialized lightning layer group');
            setTimeout(() => {
              map.invalidateSize();
              console.log('Map size invalidated for ArchivePage');
            }, 100);
            return () => {
              console.log('Cleaning up ArchivePage map');
              map.remove();
            };
          } catch (err) {
            console.error('Error initializing ArchivePage map:', err);
            setError('Failed to initialize map');
          }
        });
      }, []);

      useEffect(() => {
        if (!date) return;
        console.log('Date changed, fetching lightning strikes and outlooks for:', date);
        fetchLightningData(date, setError).then(strikes => {
          if (!mapRef.current || !lightningLayerRef.current) return;
          lightningLayerRef.current.clearLayers();
          console.log('Cleared existing lightning markers');
          strikes.forEach(s => {
            if (s.coordinates && s.coordinates.length === 2) {
              const [lon, lat] = s.coordinates;
              L.circleMarker([lat, lon], {
                radius: 4,
                color: '#ff0000',
                fillColor: '#ff0000',
                fillOpacity: 0.7,
                weight: 1
              }).addTo(lightningLayerRef.current);
            }
          });
          console.log(`Added ${strikes.length} lightning markers for ${date}`);
          setTimeout(() => {
            if (mapRef.current) {
              map.invalidateSize();
              console.log('Map size invalidated after data fetch');
            }
          }, 10);
        });
        db.collection('outlooks').where('date', '==', date).get()
          .then(snapshot => {
            const outlooksData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            console.log('Fetched outlooks for date:', date, outlooksData);
            setOutlooks(outlooksData);
            if (!outlooksData.length) {
              setSelectedOutlook(null);
            }
            setTimeout(() => {
              if (mapRef.current) {
                map.invalidateSize();
                console.log('Map size invalidated after outlook fetch');
              }
            }, 100);
          })
          .catch(err => {
            console.error('Error fetching outlooks:', err);
            setError('Failed to load outlooks');
          });
      }, [date]);

      useEffect(() => {
        if (!mapRef.current || !selectedOutlook) return;
        console.log('Selected outlook updated:', selectedOutlook.id);
        geoJsonLayersRef.current.forEach(layer => {
          if (mapRef.current.hasLayer(layer)) {
            mapRef.current.removeLayer(layer);
          }
        });
        geoJsonLayersRef.current = [];
        if (selectedOutlook.polygons) {
          const parsedPolygons = selectedOutlook.polygons.map(p => {
            try {
              return {
                ...p,
                geometry: {
                  ...p.geometry,
                  coordinates: JSON.parse(p.geometry.coordinates)
                },
                properties: {
                  ...p.properties,
                  Name: p.properties.Name || 'low risk',
                  color: p.properties.color || RISK_COLORS[p.properties.Name?.toLowerCase() || 'low risk']
                }
              };
            } catch (err) {
              console.error('Error parsing polygon:', p, err);
              return null;
            }
          }).filter(p => p !== null);
          console.log('Parsed polygons for ArchivePage:', parsedPolygons);

          const polygonsByRisk = RISK_ORDER.reduce((acc, risk) => {
            acc[risk] = parsedPolygons.filter(p => p.properties.Name?.toLowerCase() === risk);
            return acc;
          }, {});
          console.log('Polygons by risk:', polygonsByRisk);

          RISK_ORDER.forEach(risk => {
            if (polygonsByRisk[risk].length > 0) {
              const layer = L.geoJSON(polygonsByRisk[risk], {
                style: feature => {
                  const riskLevel = feature.properties.Name?.toLowerCase() || 'low risk';
                  const color = RISK_COLORS[riskLevel] || '#66c2a4';
                  if (!RISK_COLORS[riskLevel]) {
                    console.warn('Invalid risk level:', riskLevel, 'for polygon:', feature);
                  }
                  console.log('Assigning color for', riskLevel, ':', color);
                  return {
                    color,
                    fillColor: color,
                    fillOpacity: 0.4
                  };
                }
              }).addTo(mapRef.current);
              geoJsonLayersRef.current.push(layer);
              console.log('Added GeoJSON layer for', risk);
              layer.bringToFront();
            }
          });
          setTimeout(() => {
            if (mapRef.current) {
              mapRef.current.invalidateSize();
              console.log('Map size invalidated after outlook update');
            }
          }, 100);
        }
      }, [selectedOutlook]);

      return (
        <div className="p-6 container mx-auto">
          <h1 className="text-3xl font-bold text-gray-800 mb-6">Archive</h1>
          {error && <p className="text-red-500 mb-4 bg-red-100 p-2 rounded-lg">{error}</p>}
          <div className="flex flex-col md:flex-row gap-6">
            <div className="md:w-1/3 bg-white p-6 rounded-lg shadow-md">
              <input
                type="date"
                value={date}
                onChange={e => setDate(e.target.value)}
                className="w-full p-2 mb-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
              <ul className="space-y-2">
                {outlooks.map(outlook => (
                  <li
                    key={outlook.id}
                    onClick={() => setSelectedOutlook(outlook)}
                    className="cursor-pointer p-2 hover:bg-gray-100 rounded-lg"
                  >
                    {outlook.username} - {date} {outlook.score != null ? `(Score: ${outlook.score.toFixed(2)})` : '(Score pending)'}
                  </li>
                ))}
              </ul>
            </div>
            <div className="md:w-2/3">
              <div id="archive-map" className="h-[500px] w-full rounded-lg shadow-md"></div>
            </div>
          </div>
        </div>
      );
    };

    const App = () => {
      const [user, setUser] = useState(null);
      const [username, setUsername] = useState('');
      const [email, setEmail] = useState('');

      useEffect(() => {
        const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {
          if (firebaseUser) {
            try {
              const userDoc = await db.collection('users').doc(firebaseUser.uid).get();
              if (userDoc.exists) {
                setUser(firebaseUser);
                setUsername(userDoc.data().username);
                setEmail(firebaseUser.email);
                console.log('User logged in:', firebaseUser.uid, 'Username:', userDoc.data().username, 'Email:', firebaseUser.email);
              } else {
                console.warn('No user document found for UID:', firebaseUser.uid);
                setUser(null);
                setUsername('');
                setEmail('');
              }
            } catch (err) {
              console.error('Error fetching user document:', err);
              setUser(null);
              setUsername('');
              setEmail('');
            }
          } else {
            setUser(null);
            setUsername('');
            setEmail('');
            console.log('No user logged in');
          }
        });
        return () => unsubscribe();
      }, []);

      return (
        <BrowserRouter>
          <NavBar user={user} username={username} />
          <Switch>
            <Route exact path="/" component={WelcomePage} />
            <Route path="/account" component={() => <AccountPage setUser={setUser} setUsername={setUsername} setEmail={setEmail} />} />
            <Route path="/create" component={() => user ? <CreateOutlookPage user={user} username={username} email={email} /> : <Redirect to="/account" />} />
            <Route path="/view" component={ViewOutlookPage} />
            <Route path="/admin" component={() => user ? <AdminPage user={user} username={username} /> : <Redirect to="/account" />} />
            <Route path="/leaderboard" component={LeaderboardPage} />
            <Route path="/archive" component={ArchivePage} />
          </Switch>
        </BrowserRouter>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
    </script>
</body>
</html>
